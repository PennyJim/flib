<!doctype html>
<html lang="en">
    <head>
        <link rel="stylesheet" href="style.css">
        <title>flib documentation</title>
    </head>
    <body>
        <h1>Factorio Library documentation</h1>
        <p>This documentation is auto-generated by the Lua language server.
        These docs are greatly unpolished and lack any quality of life features
        whatsoever. This site will be replaced with a custom implementation in the
        future.</p>
        <nav>
            <a href="https://github.com/factoriolib/flib">GitHub</a>
            <a href="https://mods.factorio.com/mod/flib">Mod portal</a>
        </nav>
<h1>Array</h1>
<hr />
<h1>DictLangRequest</h1>
<h2>player</h2>
<pre><code class="language-lua">LuaPlayer
</code></pre>
<h2>tick</h2>
<pre><code class="language-lua">uint
</code></pre>
<hr />
<h1>DictTranslationRequest</h1>
<h2>dict</h2>
<pre><code class="language-lua">string
</code></pre>
<h2>key</h2>
<pre><code class="language-lua">string
</code></pre>
<h2>language</h2>
<pre><code class="language-lua">string
</code></pre>
<hr />
<h1>DictWipData</h1>
<hr />
<h1>Dictionary</h1>
<p>Localised strings identified by an internal key. Keys must be unique and language-agnostic.</p>
<pre><code class="language-lua">table&lt;string, LocalisedString&gt;
</code></pre>
<hr />
<h1>EventData.on_player_dictionaries_ready</h1>
<p>Called when a player's dictionaries are ready to be used. Handling this event is not required.</p>
<h2>player_index</h2>
<pre><code class="language-lua">uint
</code></pre>
<hr />
<h1>EventData.on_player_language_changed</h1>
<p>Called when a player's language changes. Handling this event is not required.</p>
<h2>language</h2>
<pre><code class="language-lua">string
</code></pre>
<h2>player_index</h2>
<pre><code class="language-lua">uint
</code></pre>
<hr />
<h1>Gui</h1>
<hr />
<h1>GuiBase</h1>
<h2>build</h2>
<pre><code class="language-lua">function GuiBase.build(player: LuaPlayer)
</code></pre>
<p>Build the GUI for the given player.</p>
<h2>change_mode</h2>
<pre><code class="language-lua">function GuiBase.change_mode(self: Gui, e: EventData.on_gui_checked_state_changed)
</code></pre>
<h2>clear_completed</h2>
<pre><code class="language-lua">function GuiBase.clear_completed(self: Gui)
</code></pre>
<h2>hide</h2>
<pre><code class="language-lua">function GuiBase.hide(self: Gui)
</code></pre>
<h2>on_textfield_confirmed</h2>
<pre><code class="language-lua">function GuiBase.on_textfield_confirmed(self: Gui, e: EventData.on_gui_confirmed)
</code></pre>
<h2>on_textfield_text_changed</h2>
<pre><code class="language-lua">function GuiBase.on_textfield_text_changed(_: any, e: EventData.on_gui_confirmed)
</code></pre>
<h2>on_todo_toggled</h2>
<pre><code class="language-lua">function GuiBase.on_todo_toggled(self: Gui, e: EventData.on_gui_checked_state_changed)
</code></pre>
<h2>on_window_closed</h2>
<pre><code class="language-lua">function GuiBase.on_window_closed(self: Gui)
</code></pre>
<h2>show</h2>
<pre><code class="language-lua">function GuiBase.show(self: Gui)
</code></pre>
<h2>toggle_pinned</h2>
<pre><code class="language-lua">function GuiBase.toggle_pinned(self: Gui)
</code></pre>
<h2>toggle_visible</h2>
<pre><code class="language-lua">function GuiBase.toggle_visible(self: Gui)
</code></pre>
<h2>update_footer</h2>
<pre><code class="language-lua">function GuiBase.update_footer(self: Gui)
</code></pre>
<hr />
<h1>GuiElemDef</h1>
<p>A GUI element definition. This extends <code>LuaGuiElement.add_param</code> with several new attributes.
Children may be defined in the array portion as an alternative to the <code>children</code> subtable.</p>
<pre><code class="language-lua">GuiElemDefClass|GuiElemDefClass|GuiElemDefClass[][]
</code></pre>
<hr />
<h1>GuiElemDefClass</h1>
<p>A GUI element definition. This extends <code>LuaGuiElement.add_param</code> with several new attributes.
Children may be defined in the array portion as an alternative to the <code>children</code> subtable.</p>
<h2>children</h2>
<pre><code class="language-lua">GuiElemDefClass|GuiElemDefClass[][]?
</code></pre>
<p>Children to add to this element</p>
<h2>content</h2>
<pre><code class="language-lua">(GuiElemDefClass|GuiElemDefClass|GuiElemDefClass[][])?
</code></pre>
<p>To add a tab, specify <code>tab</code> and <code>content</code> and leave all other fields unset.</p>
<h2>drag_target</h2>
<pre><code class="language-lua">string?
</code></pre>
<p>Set the element's drag target to the element whose name matches this string. The drag target must be present in the <code>elems</code> table.</p>
<h2>elem_mods</h2>
<pre><code class="language-lua">LuaGuiElement?
</code></pre>
<p>Modifications to make to the element itself</p>
<h2>handler</h2>
<pre><code class="language-lua">(fun(e: EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7))|table&lt;defines.events,...(too long).....(+7))&gt;)?
</code></pre>
<p>Handler(s) to assign to this element</p>
<h2>style_mods</h2>
<pre><code class="language-lua">LuaStyle?
</code></pre>
<p>Modifications to make to the element's style</p>
<h2>tab</h2>
<pre><code class="language-lua">(GuiElemDefClass|GuiElemDefClass|GuiElemDefClass[][])?
</code></pre>
<p>To add a tab, specify <code>tab</code> and <code>content</code> and leave all other fields unset.</p>
<hr />
<h1>GuiElemHandler</h1>
<p>A handler function to invoke when receiving GUI events for this element. Alternatively, separate handlers may be
specified for different events.</p>
<pre><code class="language-lua">fun(e: EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7))|table&lt;defines.events, ...(too long)...d...(+7))&gt;
</code></pre>
<hr />
<h1>GuiEventData</h1>
<p>Aggregate type of all possible GUI events.</p>
<pre><code class="language-lua">EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7)
</code></pre>
<hr />
<h1>IconSpecification</h1>
<h2>icon</h2>
<pre><code class="language-lua">string
</code></pre>
<h2>icon_size</h2>
<pre><code class="language-lua">int
</code></pre>
<hr />
<h1>MigrationsTable</h1>
<p>Migration code to run for specific mod version. A given function will run if the previous mod version is less
than the given version.</p>
<h1>Example</h1>
<pre><code class="language-lua">{
  [&quot;1.0.1&quot;] = function()
    global.foo = nil
    for _, player_table in pairs(global.players) do
      player_table.bar = &quot;Lorem ipsum&quot;
    end
  end,
  [&quot;1.0.7&quot;] = function()
    global.bar = {}
  end
  [&quot;1.1.0&quot;] = function(arg)
    global.foo = arg
  end
}
</code></pre>
<p>If the mod is upgraded from 1.0.4 to 1.1.0, then the migrations for 1.0.7 and 1.1.0 will be run.</p>
<pre><code class="language-lua">table&lt;string, fun(...any)&gt;
</code></pre>
<hr />
<h1>Queue</h1>
<hr />
<h1>RawDictionary</h1>
<hr />
<h1>SpriteSpecification</h1>
<hr />
<h1>TaskIdent</h1>
<p>A unique identifier for a previously added task, used in <code>on-tick-n.remove</code>.</p>
<h2>index</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The tasks' index in the tick's <code>Tasks</code> table.</p>
<h2>tick</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The tick this task is scheduled for.</p>
<hr />
<h1>Tasks</h1>
<p>A table of tasks.</p>
<p>Each task can be anything that is not a function, as specified in <code>on-tick-n.add</code>.</p>
<p><strong>This is not an array, there may be gaps. Always use <code>pairs</code> to iterate this table.</strong></p>
<h1>Example</h1>
<pre><code class="language-lua">event.on_tick(function(e)
  for _, task in pairs(on_tick_n.retrieve(e.tick) or {}) do
    if task == &quot;say_hi&quot; then
      game.print(&quot;Hello there!&quot;)
    elseif task == &quot;order_66&quot; then
      for _, player in pairs(game.players) do
        player.die()
      end
    end
  end
end)
</code></pre>
<pre><code class="language-lua">table&lt;number, any&gt;
</code></pre>
<hr />
<h1>TrainCompositionCounts</h1>
<h2>back_movers</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The number of back-facing locomotives in the train.</p>
<h2>front_movers</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The number of front-facing locomotives in the train.</p>
<h2>total</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The total number of rolling stocks in the train.</p>
<h2>wagons</h2>
<pre><code class="language-lua">number
</code></pre>
<p>The number of wagons in the train.</p>
<hr />
<h1>TranslatedDictionary</h1>
<p>Translations are identified by their internal key. If the translation failed, then it will not be present. Locale
fallback groups can be used if every key needs a guaranteed translation.</p>
<pre><code class="language-lua">table&lt;string, string&gt;
</code></pre>
<hr />
<h1>flib_bounding_box</h1>
<p>Utilities for manipulating bounding boxes. All functions support both the shorthand and explicit syntaxes for boxes
and positions, and will preserve the syntax that was passed in. Boxes are considered immutable; all functions will
return new boxes.</p>
<pre><code class="language-lua">local flib_bounding_box = require(&quot;__flib__/bounding-box&quot;)
</code></pre>
<h2>ceil</h2>
<pre><code class="language-lua">function flib_bounding_box.ceil(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box expanded to the nearest tile edges.</p>
<h2>center</h2>
<pre><code class="language-lua">function flib_bounding_box.center(box: BoundingBox)
  -&gt; MapPosition
</code></pre>
<p>Calculate the centerpoint of the box.</p>
<h2>contains_box</h2>
<pre><code class="language-lua">function flib_bounding_box.contains_box(box1: BoundingBox, box2: BoundingBox)
  -&gt; boolean
</code></pre>
<p>Check if the first box contains the second box.</p>
<h2>contains_position</h2>
<pre><code class="language-lua">function flib_bounding_box.contains_position(box: BoundingBox, pos: MapPosition)
  -&gt; boolean
</code></pre>
<p>Check if the given box contains the given position.</p>
<h2>ensure_explicit</h2>
<pre><code class="language-lua">function flib_bounding_box.ensure_explicit(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return the box in explicit form.</p>
<h2>ensure_short</h2>
<pre><code class="language-lua">function flib_bounding_box.ensure_short(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return the box in shorthand form.</p>
<h2>expand_to_contain_box</h2>
<pre><code class="language-lua">function flib_bounding_box.expand_to_contain_box(box1: BoundingBox, box2: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box with initial dimensions box1, expanded to contain box2.</p>
<h2>expand_to_contain_position</h2>
<pre><code class="language-lua">function flib_bounding_box.expand_to_contain_position(box: BoundingBox, pos: MapPosition)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box expanded to contain the given position.</p>
<h2>floor</h2>
<pre><code class="language-lua">function flib_bounding_box.floor(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box shrunk to the nearest tile edges.</p>
<h2>from_dimensions</h2>
<pre><code class="language-lua">function flib_bounding_box.from_dimensions(center: MapPosition, width: number, height: number)
  -&gt; BoundingBox
</code></pre>
<p>Create a new box from a centerpoint and dimensions.</p>
<h2>from_position</h2>
<pre><code class="language-lua">function flib_bounding_box.from_position(pos: MapPosition, snap?: boolean)
  -&gt; BoundingBox
</code></pre>
<p>Create a 1x1 box from the given position, optionally snapped to the containing tile edges.</p>
<h2>height</h2>
<pre><code class="language-lua">function flib_bounding_box.height(box: BoundingBox)
  -&gt; number
</code></pre>
<p>Calculate the height of the box.</p>
<h2>intersects_box</h2>
<pre><code class="language-lua">function flib_bounding_box.intersects_box(box1: BoundingBox, box2: BoundingBox)
  -&gt; boolean
</code></pre>
<p>Check if the first box intersects (overlaps) the second box.</p>
<h2>move</h2>
<pre><code class="language-lua">function flib_bounding_box.move(box: BoundingBox, delta: MapPosition)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box with  the same dimensions, moved by the given delta.</p>
<h2>recenter_on</h2>
<pre><code class="language-lua">function flib_bounding_box.recenter_on(box: BoundingBox, pos: MapPosition)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box with the same dimensions centered on the given position.</p>
<h2>resize</h2>
<pre><code class="language-lua">function flib_bounding_box.resize(box: BoundingBox, delta: number)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box grown or shrunk by the given delta. A positive delta will grow the box, a negative delta will
shrink it.</p>
<h2>rotate</h2>
<pre><code class="language-lua">function flib_bounding_box.rotate(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box rotated 90 degrees about its center.</p>
<h2>square</h2>
<pre><code class="language-lua">function flib_bounding_box.square(box: BoundingBox)
  -&gt; BoundingBox
</code></pre>
<p>Return a new box expanded to create a square.</p>
<h2>width</h2>
<pre><code class="language-lua">function flib_bounding_box.width(box: BoundingBox)
  -&gt; number
</code></pre>
<p>Calculate the width of the box.</p>
<hr />
<h1>flib_data_util</h1>
<p>Utilities for data stage prototype manipulation.</p>
<pre><code class="language-lua">local flib_data_util = require(&quot;__flib__/data-util&quot;)
</code></pre>
<h2>black_image</h2>
<pre><code class="language-lua">string
</code></pre>
<p>A black image, for use with tool backgrounds. This image is 1x1.</p>
<h2>build_sprite</h2>
<pre><code class="language-lua">function flib_data_util.build_sprite(name?: string, position?: MapPosition, filename?: string, size?: Vector, mipmap_count?: number, mods?: table)
  -&gt; SpriteSpecification
</code></pre>
<p>Build a sprite from constituent parts.</p>
<h2>copy_prototype</h2>
<pre><code class="language-lua">function flib_data_util.copy_prototype(prototype: table, new_name: string, remove_icon?: boolean)
  -&gt; table
</code></pre>
<p>Copy a prototype, assigning a new name and minable properties.</p>
<p>@<em>param</em> <code>new_name</code> — string</p>
<h2>create_icons</h2>
<pre><code class="language-lua">function flib_data_util.create_icons(prototype: table, new_layers?: IconSpecification[])
  -&gt; IconSpecification[]|nil
</code></pre>
<p>Copy prototype.icon/icons to a new fully defined icons array, optionally adding new icon layers.</p>
<p>Returns <code>nil</code> if the prototype's icons are incorrectly or incompletely defined.</p>
<h2>dark_red_button_tileset</h2>
<pre><code class="language-lua">string
</code></pre>
<p>A dark red button tileset. Used for the <code>flib_tool_button_dark_red</code> style.</p>
<h2>empty_image</h2>
<pre><code class="language-lua">string
</code></pre>
<p>An empty image. This image is 8x8 to facilitate usage with GUI styles.</p>
<h2>get_energy_value</h2>
<pre><code class="language-lua">function flib_data_util.get_energy_value(energy_string: string)
  -&gt; number?
  2. string?
</code></pre>
<p>Convert an energy string to base unit value + suffix.</p>
<p>Returns <code>nil</code> if <code>energy_string</code> is incorrectly formatted.</p>
<h2>planner_base_image</h2>
<pre><code class="language-lua">string
</code></pre>
<p>A desaturated planner image. Tint this sprite to easily add your own planners.</p>
<hr />
<h1>flib_dictionary</h1>
<p>Utilities for creating dictionaries of localised string translations.</p>
<pre><code class="language-lua">local flib_dictionary = require(&quot;__flib__/dictionary-lite&quot;)
</code></pre>
<h2>add</h2>
<pre><code class="language-lua">function flib_dictionary.add(dict_name: string, key: string, localised: LocalisedString)
</code></pre>
<p>Add the given string to the dictionary.</p>
<h2>events</h2>
<pre><code class="language-lua">table
</code></pre>
<p>For use with <code>__core__/lualib/event_handler</code>. Pass <code>flib_dictionary</code> into <code>handler.add_lib</code> to
handle all relevant events automatically.</p>
<h2>get</h2>
<pre><code class="language-lua">function flib_dictionary.get(player_index: uint, dict_name: string)
  -&gt; table&lt;string, string&gt;?
</code></pre>
<p>Get the specified dictionary for the player. Will return <code>nil</code> if the dictionary has not finished translating.</p>
<h2>get_all</h2>
<pre><code class="language-lua">function flib_dictionary.get_all(player_index: uint)
  -&gt; table&lt;string, table&lt;string, string&gt;&gt;?
</code></pre>
<p>Get all dictionaries for the player. Will return <code>nil</code> if the player's language has not finished translating.</p>
<h2>handle_events</h2>
<pre><code class="language-lua">function flib_dictionary.handle_events()
</code></pre>
<p>Handle all non-bootstrap events with default event handlers. Will not overwrite any existing handlers. If you have
custom handlers for on_tick, on_string_translated, or on_player_joined_game, ensure that you call the corresponding
module lifecycle handler..</p>
<h2>new</h2>
<pre><code class="language-lua">function flib_dictionary.new(name: string, initial_strings?: table&lt;string, LocalisedString&gt;)
</code></pre>
<p>Create a new dictionary. The name must be unique.</p>
<h2>on_configuration_changed</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>on_init</h2>
<pre><code class="language-lua">function flib_dictionary.on_init()
</code></pre>
<h2>on_player_dictionaries_ready</h2>
<pre><code class="language-lua">unknown
</code></pre>
<h2>on_player_joined_game</h2>
<pre><code class="language-lua">function flib_dictionary.on_player_joined_game(e: EventData.on_player_joined_game)
</code></pre>
<h2>on_player_language_changed</h2>
<pre><code class="language-lua">unknown
</code></pre>
<h2>on_string_translated</h2>
<pre><code class="language-lua">function flib_dictionary.on_string_translated(e: EventData.on_string_translated)
</code></pre>
<h2>on_tick</h2>
<pre><code class="language-lua">function flib_dictionary.on_tick()
</code></pre>
<hr />
<h1>flib_dictionary_global</h1>
<hr />
<h1>flib_direction</h1>
<p>Functions for working with directions.</p>
<pre><code class="language-lua">local flib_direction = require(&quot;__flib__/direction&quot;)
</code></pre>
<h2>east</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.east</p>
<h2>from_positions</h2>
<pre><code class="language-lua">function flib_direction.from_positions(source: MapPosition, target: MapPosition, round?: boolean)
  -&gt; defines.direction
</code></pre>
<p>Calculate the direction of travel from the source to the target.</p>
<p>@<em>param</em> <code>round</code> — If true, round to the nearest <code>defines.direction</code>.</p>
<h2>next</h2>
<pre><code class="language-lua">function flib_direction.next(direction: defines.direction, eight_way?: boolean)
  -&gt; defines.direction
</code></pre>
<p>Calculate the next four-way or eight-way direction.</p>
<h2>north</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.north</p>
<h2>northeast</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.northeast</p>
<h2>northwest</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.northwest</p>
<h2>opposite</h2>
<pre><code class="language-lua">function flib_direction.opposite(direction: defines.direction)
  -&gt; defines.direction
</code></pre>
<p>Calculate the opposite direction.</p>
<h2>previous</h2>
<pre><code class="language-lua">function flib_direction.previous(direction: defines.direction, eight_way?: boolean)
  -&gt; defines.direction
</code></pre>
<p>Calculate the previous four-way or eight-way direction.</p>
<h2>south</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.south</p>
<h2>southeast</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.southeast</p>
<h2>southwest</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.southwest</p>
<h2>to_orientation</h2>
<pre><code class="language-lua">function flib_direction.to_orientation(direction: defines.direction)
  -&gt; RealOrientation
</code></pre>
<p>Calculate an orientation from a direction.</p>
<h2>to_vector</h2>
<pre><code class="language-lua">function flib_direction.to_vector(direction: defines.direction, distance?: number)
  -&gt; MapPosition
</code></pre>
<p>Calculate a vector from a direction.</p>
<p>@<em>param</em> <code>distance</code> — default: <code>1</code></p>
<h2>to_vector_2d</h2>
<pre><code class="language-lua">function flib_direction.to_vector_2d(direction: defines.direction, longitudinal: number, orthogonal: number)
  -&gt; MapPosition?
</code></pre>
<p>Calculate a two-dimensional vector from a cardinal direction.</p>
<p>@<em>param</em> <code>longitudinal</code> — Distance to move in the specified direction.</p>
<p>@<em>param</em> <code>orthogonal</code> — Distance to move perpendicular to the specified direction. A negative distance will move &quot;left&quot; and a positive distance will move &quot;right&quot; from the perspective of the direction.</p>
<h2>west</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>defines.direction.west</p>
<hr />
<h1>flib_format</h1>
<p>Various string formatting functions.</p>
<pre><code class="language-lua">local flib_format = require(&quot;__flib__/format&quot;)
</code></pre>
<h2>number</h2>
<pre><code class="language-lua">function flib_format.number(amount: number, append_suffix?: boolean, fixed_precision?: number)
  -&gt; string
</code></pre>
<p>Format a number for display, adding commas and an optional SI suffix.
Specify <code>fixed_precision</code> to display the number with the given width,
adjusting precision as necessary.</p>
<h2>time</h2>
<pre><code class="language-lua">function flib_format.time(tick?: uint, include_leading_zeroes?: boolean)
  -&gt; string
</code></pre>
<p>Convert the given tick or game.tick into &quot;[hh:]mm:ss&quot; format.</p>
<hr />
<h1>flib_gui</h1>
<p>Utilities for building GUIs and handling GUI events.</p>
<pre><code class="language-lua">local flib_gui = require(&quot;__flib__/gui-lite&quot;)
</code></pre>
<h2>add</h2>
<pre><code class="language-lua">function flib_gui.add(parent: LuaGuiElement, def: GuiElemDefClass|GuiElemDefClass|GuiElemDefClass[][], elems?: table&lt;string, LuaGuiElement&gt;)
  -&gt; elems: table&lt;string, LuaGuiElement&gt;
  2. first: LuaGuiElement
</code></pre>
<p>Add a new child or children to the given GUI element.</p>
<p>@<em>param</em> <code>def</code> — Can be a single element, or an array of elements.</p>
<p>@<em>param</em> <code>elems</code> — Optional initial <code>elems</code> table.</p>
<p>@<em>return</em> <code>elems</code> — Elements with names will be collected into this table.</p>
<p>@<em>return</em> <code>first</code> — The element that was created first;  the &quot;top level&quot; element.</p>
<h2>add_handlers</h2>
<pre><code class="language-lua">function flib_gui.add_handlers(new_handlers: table&lt;string, fun(e: EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7))&gt;, wrapper?: fun(e: EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7), handler: function))
</code></pre>
<p>Add the given handler functions to the registry for use with <code>flib_gui.add</code>. Each handler must have a unique name. If a
<code>wrapper</code> function is provided, it will be called instead, and will receive the event data and handler. The wrapper
can be used to execute logic or gather data common to all handler functions for this GUI.</p>
<h2>dispatch</h2>
<pre><code class="language-lua">function flib_gui.dispatch(e: EventData.on_gui_checked_state_changed|EventData.on_gui_click|EventData.on_gui_closed|EventData.on_gui_confirmed|EventData.on_gui_elem_changed...(+7))
  -&gt; handled: boolean
</code></pre>
<p>Dispatch the handler associated with this event and GUI element. The handler must have been added using
<code>flib_gui.add_handlers</code>.</p>
<p>@<em>return</em> <code>handled</code> — True if an event handler was called.</p>
<h2>events</h2>
<pre><code class="language-lua">table
</code></pre>
<p>For use with <code>__core__/lualib/event_handler</code>. Pass <code>flib_gui</code> into <code>handler.add_lib</code> to handle
all GUI events automatically.</p>
<h2>handle_events</h2>
<pre><code class="language-lua">function flib_gui.handle_events()
</code></pre>
<p>Handle all GUI events with <code>flib_gui.dispatch</code>. Will not overwrite any existing event handlers.</p>
<hr />
<h1>flib_math</h1>
<p>Extension of the Lua 5.2 math library.</p>
<pre><code class="language-lua">local flib_math = require(&quot;__flib__/math&quot;)
</code></pre>
<h2>ceil_to</h2>
<pre><code class="language-lua">function flib_math.ceil_to(num: number, num_decimals: number)
  -&gt; number
</code></pre>
<p>Ceil a number to N decimal places.
Use <code>math.ceil</code> directly if no decimals are needed.</p>
<h2>ceiled</h2>
<pre><code class="language-lua">function flib_math.ceiled(num: number, divisor?: number)
  -&gt; number|unknown
</code></pre>
<p>Ceil a number to the nearest multiple of divisor.</p>
<p>@<em>param</em> <code>divisor</code> — <code>num</code> will be ceiled to the nearest multiple of <code>divisor</code> (default: 1).</p>
<h2>clamp</h2>
<pre><code class="language-lua">function flib_math.clamp(x: number, min?: number, max?: number)
  -&gt; number
</code></pre>
<p>Clamp a number between minimum and maximum values.</p>
<p>@<em>param</em> <code>min</code> — default 0</p>
<p>@<em>param</em> <code>max</code> — default 1</p>
<h2>deg_to_rad</h2>
<pre><code class="language-lua">number
</code></pre>
<p>Multiply by degrees to convert to radians.</p>
<pre><code class="language-lua">local rad = 1 x flib_math.deg_to_rad -- 0.0174533
</code></pre>
<h2>floor_to</h2>
<pre><code class="language-lua">function flib_math.floor_to(num: number, num_decimals: number)
  -&gt; number
</code></pre>
<p>Floor a number to N decimal places.
Use <code>math.floor</code> directly if no decimals are needed.</p>
<h2>floored</h2>
<pre><code class="language-lua">function flib_math.floored(num: number, divisor?: number)
  -&gt; number|unknown
</code></pre>
<p>Floor a number to the nearest multiple of divisor.</p>
<p>@<em>param</em> <code>divisor</code> — <code>num</code> will be floored to the nearest multiple of <code>divisor</code> (default: 1).</p>
<h2>lerp</h2>
<pre><code class="language-lua">function flib_math.lerp(num1: number, num2: number, amount: number)
  -&gt; number
</code></pre>
<p>Linearly interpolate between <code>num1</code> and <code>num2</code> by <code>amount</code>.</p>
<p>The parameter <code>amount</code> is clamped between <code>0</code> and <code>1</code>.</p>
<p>When <code>amount = 0</code>, returns <code>num1</code>.</p>
<p>When <code>amount = 1</code>, returns <code>num2</code>.</p>
<p>When <code>amount = 0.5</code>, returns the midpoint of <code>num1</code> and <code>num2</code>.</p>
<h2>max_double</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>max_int</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>2,147,483,647</p>
<h2>max_int16</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>32,767</p>
<h2>max_int53</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>9,007,199,254,740,991</p>
<h2>max_int8</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>127</p>
<h2>max_uint</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>4,294,967,295</p>
<h2>max_uint16</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>65,535</p>
<h2>max_uint8</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>255</p>
<h2>maximum</h2>
<pre><code class="language-lua">function flib_math.maximum(set: number[])
  -&gt; number
</code></pre>
<p>Returns the argument with the maximum value from a set.</p>
<h2>mean</h2>
<pre><code class="language-lua">function flib_math.mean(set: number[])
  -&gt; number
</code></pre>
<p>Calculate the mean (average) of a set of numbers.</p>
<h2>midrange</h2>
<pre><code class="language-lua">function flib_math.midrange(set: number[])
  -&gt; number
</code></pre>
<p>Calculate the mean of the largest and the smallest values in a set of numbers.</p>
<h2>min_double</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>min_int</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>-2,147,483,648</p>
<h2>min_int16</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>-32,768</p>
<h2>min_int53</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>-9,007,199,254,740,992</p>
<h2>min_int8</h2>
<pre><code class="language-lua">integer
</code></pre>
<p>-128</p>
<h2>minimum</h2>
<pre><code class="language-lua">function flib_math.minimum(set: number[])
  -&gt; number
</code></pre>
<p>Returns the argument with the minimum value from a set.</p>
<h2>rad_to_deg</h2>
<pre><code class="language-lua">number
</code></pre>
<p>Multiply by radians to convert to degrees.</p>
<pre><code class="language-lua">local deg = 1 x flib_math.rad_to_deg -- 57.2958
</code></pre>
<h2>range</h2>
<pre><code class="language-lua">function flib_math.range(set: number[])
  -&gt; number
</code></pre>
<p>Calculate the range in a set of numbers.</p>
<h2>round</h2>
<pre><code class="language-lua">function flib_math.round(num: number, divisor?: number)
  -&gt; number
</code></pre>
<p>Round a number to the nearest multiple of divisor.
Defaults to nearest integer if divisor is not provided.</p>
<p>From <a href="http://lua-users.org/wiki/SimpleRound">lua-users.org</a>.</p>
<p>@<em>param</em> <code>divisor</code> — <code>num</code> will be rounded to the nearest multiple of <code>divisor</code> (default: 1).</p>
<h2>round_to</h2>
<pre><code class="language-lua">function flib_math.round_to(num: number, num_decimals: number)
  -&gt; number
</code></pre>
<p>Round a number to the nearest N decimal places.</p>
<p>From <a href="http://lua-users.org/wiki/SimpleRound">lua-users.org</a>.</p>
<h2>sign</h2>
<pre><code class="language-lua">function flib_math.sign(x: number)
  -&gt; number
</code></pre>
<p>Return the signedness of a number as a multiplier.</p>
<h2>sum</h2>
<pre><code class="language-lua">function flib_math.sum(set: number[])
  -&gt; number
</code></pre>
<p>Calculate the sum of a set of numbers.</p>
<hr />
<h1>flib_migration</h1>
<p>Mod migration and version comparison functions.</p>
<pre><code class="language-lua">local flib_migration = require(&quot;__flib__/migration&quot;)
</code></pre>
<h2>format_version</h2>
<pre><code class="language-lua">function flib_migration.format_version(version: string, format?: string)
  -&gt; string?
</code></pre>
<p>Normalize version strings for easy comparison.</p>
<h3>Examples</h3>
<pre><code class="language-lua">migration.format_version(&quot;1.10.1234&quot;, &quot;%04d&quot;)
migration.format_version(&quot;3&quot;, &quot;%02d&quot;)
</code></pre>
<p>@<em>param</em> <code>format</code> — default: <code>%02d</code></p>
<h2>handle_on_configuration_changed</h2>
<pre><code class="language-lua">function flib_migration.handle_on_configuration_changed(version_migrations?: table&lt;string, fun(...any)&gt;, generic_handler?: fun(e: ConfigurationChangedData))
</code></pre>
<p>Handle on_configuration_changed with the given generic and version-specific migrations. Will override any existing
on_configuration_changed event handler. Both arguments are optional.</p>
<h2>is_newer_version</h2>
<pre><code class="language-lua">function flib_migration.is_newer_version(old_version: string, current_version: string, format?: string)
  -&gt; boolean?
</code></pre>
<p>Check if current_version is newer than old_version.</p>
<p>@<em>param</em> <code>format</code> — default: <code>%02d</code></p>
<h2>on_config_changed</h2>
<pre><code class="language-lua">function flib_migration.on_config_changed(e: ConfigurationChangedData, migrations?: table&lt;string, fun(...any)&gt;, mod_name?: string, ...any)
  -&gt; run_generic_micrations: boolean
</code></pre>
<p>Determine if migrations need to be run for this mod, then run them if needed.</p>
<h3>Examples</h3>
<pre><code class="language-lua">script.on_configuration_changed(function(e)
  if migration.on_config_changed(e, migrations) then
    -- Run generic (non-init) migrations
    rebuild_prototype_data()
  end
end
</code></pre>
<p>@<em>param</em> <code>mod_name</code> — The mod to check against. Defaults to the current mod.</p>
<p>@<em>param</em> <code>...</code> — All additional arguments will be passed to each function within <code>migrations</code>.</p>
<h2>run</h2>
<pre><code class="language-lua">function flib_migration.run(old_version: string, migrations: table&lt;string, fun(...any)&gt;, format?: string, ...any)
</code></pre>
<p>Run migrations against the given version.</p>
<p>@<em>param</em> <code>format</code> — default: <code>%02d</code></p>
<p>@<em>param</em> <code>...</code> — All additional arguments will be passed to each function within <code>migrations</code>.</p>
<hr />
<h1>flib_on_tick_n</h1>
<p>Schedule tasks to be executed later.</p>
<pre><code class="language-lua">local flib_on_tick_n = require(&quot;__flib__/on-tick-n&quot;)
</code></pre>
<h2>add</h2>
<pre><code class="language-lua">function flib_on_tick_n.add(tick: number, task: any)
  -&gt; ident: TaskIdent
</code></pre>
<p>Add a task to execute on the given tick.</p>
<p>@<em>param</em> <code>task</code> — The data representing this task. This can be anything except for a <code>function</code>.</p>
<p>@<em>return</em> <code>ident</code> — An identifier for the task. Save this if you might remove the task before execution.</p>
<h2>init</h2>
<pre><code class="language-lua">function flib_on_tick_n.init()
</code></pre>
<p>Initialize the module's script data table.</p>
<p>Must be called at the <strong>beginning</strong> of <code>on_init</code>. Can also be used to delete all current tasks.</p>
<h2>remove</h2>
<pre><code class="language-lua">function flib_on_tick_n.remove(ident: TaskIdent)
  -&gt; boolean
</code></pre>
<p>Remove a scheduled task.</p>
<p>@<em>param</em> <code>ident</code> — The identifier object for the task, as returned from <code>on-tick-n.add</code>.</p>
<h2>retrieve</h2>
<pre><code class="language-lua">function flib_on_tick_n.retrieve(tick: number)
  -&gt; table&lt;number, any&gt;?
</code></pre>
<p>Retrieve the tasks for the given tick, if any.</p>
<p>Must be called <strong>during</strong> <code>on_tick</code>.</p>
<hr />
<h1>flib_orientation</h1>
<p>Functions for working with orientations.</p>
<pre><code class="language-lua">local flib_orientation = require(&quot;__flib__/orientation&quot;)
</code></pre>
<h2>add</h2>
<pre><code class="language-lua">function flib_orientation.add(orientation1: number, orientation2: number)
  -&gt; the: number
</code></pre>
<p>Add two orientations together.</p>
<p>@<em>return</em> <code>the</code> — orientations added together</p>
<h2>east</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>north</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>northeast</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>northwest</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>opposite</h2>
<pre><code class="language-lua">function flib_orientation.opposite(orientation: number)
  -&gt; number
</code></pre>
<p>Returns the opposite orientation.</p>
<h2>south</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>southeast</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>southwest</h2>
<pre><code class="language-lua">number
</code></pre>
<h2>to_direction</h2>
<pre><code class="language-lua">function flib_orientation.to_direction(orientation: number, eight_way: boolean)
  -&gt; defines.direction
</code></pre>
<p>Returns a 4way or 8way direction from an orientation.</p>
<h2>west</h2>
<pre><code class="language-lua">number
</code></pre>
<hr />
<h1>flib_position</h1>
<p>Utilities for manipulating positions. All functions support both the shorthand and explicit syntaxes and will
preserve the syntax that was passed in.</p>
<pre><code class="language-lua">local flib_position = require(&quot;__flib__/position&quot;)
</code></pre>
<h2>add</h2>
<pre><code class="language-lua">function flib_position.add(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Add two positions.</p>
<h2>ceil</h2>
<pre><code class="language-lua">function flib_position.ceil(pos: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Ceil the given position.</p>
<h2>distance</h2>
<pre><code class="language-lua">function flib_position.distance(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; number
</code></pre>
<p>Calculate the distance between two positions.</p>
<h2>distance_squared</h2>
<pre><code class="language-lua">function flib_position.distance_squared(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; number
</code></pre>
<p>Calculate the squared distance between two positions.</p>
<h2>div</h2>
<pre><code class="language-lua">function flib_position.div(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Divide two positions.</p>
<h2>ensure_explicit</h2>
<pre><code class="language-lua">function flib_position.ensure_explicit(pos: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Return the position in explicit form.</p>
<h2>ensure_short</h2>
<pre><code class="language-lua">function flib_position.ensure_short(pos: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Return the  position in shorthand form.</p>
<h2>eq</h2>
<pre><code class="language-lua">function flib_position.eq(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; boolean
</code></pre>
<p>Test if two positions are equal.</p>
<h2>floor</h2>
<pre><code class="language-lua">function flib_position.floor(pos: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Floor the given position.</p>
<h2>from_chunk</h2>
<pre><code class="language-lua">function flib_position.from_chunk(pos: ChunkPosition)
  -&gt; TilePosition
</code></pre>
<p>Convert a <code>ChunkPosition</code> into a <code>TilePosition</code> by multiplying by 32.</p>
<h2>le</h2>
<pre><code class="language-lua">function flib_position.le(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; boolean
</code></pre>
<p>Test if <code>pos1</code> is less than or equal to <code>pos2</code>.</p>
<h2>lt</h2>
<pre><code class="language-lua">function flib_position.lt(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; boolean
</code></pre>
<p>Test if <code>pos1</code> is less than <code>pos2</code>.</p>
<h2>mod</h2>
<pre><code class="language-lua">function flib_position.mod(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Take the remainder (modulus) of two positions.</p>
<h2>mul</h2>
<pre><code class="language-lua">function flib_position.mul(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Multiply two positions.</p>
<h2>pow</h2>
<pre><code class="language-lua">function flib_position.pow(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Take the power of two positions. <code>pos1^pos2</code>.</p>
<h2>sub</h2>
<pre><code class="language-lua">function flib_position.sub(pos1: &lt;P&gt;, pos2: &lt;P&gt;)
  -&gt; &lt;P&gt;
</code></pre>
<p>Subtract two positions.</p>
<h2>to_chunk</h2>
<pre><code class="language-lua">function flib_position.to_chunk(pos: MapPosition|TilePosition)
  -&gt; ChunkPosition
</code></pre>
<p>Convert a <code>MapPosition</code> or <code>TilePosition</code> into a <code>ChunkPosition</code> by dividing by 32 and flooring.</p>
<h2>to_tile</h2>
<pre><code class="language-lua">function flib_position.to_tile(pos: MapPosition)
  -&gt; TilePosition
</code></pre>
<p>Convert a <code>MapPosition</code> into a <code>TilePosition</code> by flooring.</p>
<hr />
<h1>flib_queue</h1>
<p>Lua queue implementation.</p>
<p>Based on &quot;Queues and Double Queues&quot; from <a href="http://www.lua.org/pil/11.4.html">Programming in Lua</a>.</p>
<pre><code class="language-lua">local flib_queue = require(&quot;__flib__/queue&quot;)
</code></pre>
<h2>iter</h2>
<pre><code class="language-lua">function flib_queue.iter(self: Queue&lt;&lt;T&gt;&gt;)
  -&gt; fun(self: Queue&lt;&lt;T&gt;&gt;, index: integer):&lt;T&gt;
</code></pre>
<p>Iterate over a queue's elements from the beginning to the end.</p>
<h1>Example</h1>
<pre><code class="language-lua">local my_queue = queue.new()
for i = 1, 10 do
  queue.push_back(my_queue, 1)
end

-- 1 2 3 4 5 6 7 8 9 10
for num in queue.iter(my_queue) do
  log(i)
end
</code></pre>
<h2>iter_left</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>iter_rev</h2>
<pre><code class="language-lua">function flib_queue.iter_rev(self: Queue&lt;&lt;T&gt;&gt;)
  -&gt; fun(self: Queue&lt;&lt;T&gt;&gt;, index: integer):&lt;T&gt;
</code></pre>
<p>Iterate over a queue's elements from the end to the beginning.</p>
<h1>Example</h1>
<pre><code class="language-lua">local my_queue = queue.new()
for i = 1, 10 do
  queue.push_back(my_queue, 1)
end

-- 10 9 8 7 6 5 4 3 2 1
for num in queue.iter_rev(my_queue) do
  log(i)
end
</code></pre>
<h2>iter_right</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>length</h2>
<pre><code class="language-lua">function flib_queue.length(self: Queue&lt;&lt;T&gt;&gt;)
  -&gt; number
</code></pre>
<p>Get the length of the queue.</p>
<h2>new</h2>
<pre><code class="language-lua">function flib_queue.new()
  -&gt; Queue
</code></pre>
<p>Create a new queue.</p>
<h2>pop_back</h2>
<pre><code class="language-lua">function flib_queue.pop_back(self: Queue&lt;&lt;T&gt;&gt;)
  -&gt; &lt;T&gt;?
</code></pre>
<p>Retrieve an element from the back of the queue.</p>
<h2>pop_front</h2>
<pre><code class="language-lua">function flib_queue.pop_front(self: Queue&lt;&lt;T&gt;&gt;)
  -&gt; &lt;T&gt;?
</code></pre>
<p>Retrieve an element from the front of the queue.</p>
<h2>pop_left</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>pop_right</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>push_back</h2>
<pre><code class="language-lua">function flib_queue.push_back(self: Queue&lt;&lt;T&gt;&gt;, value: &lt;T&gt;)
</code></pre>
<p>Push an element into the back of the queue.</p>
<h2>push_front</h2>
<pre><code class="language-lua">function flib_queue.push_front(self: Queue&lt;&lt;T&gt;&gt;, value: &lt;T&gt;)
</code></pre>
<p>Push an element into the front of the queue.</p>
<h2>push_left</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>push_right</h2>
<pre><code class="language-lua">function
</code></pre>
<hr />
<h1>flib_table</h1>
<p>Extension of the Lua 5.2 table library.</p>
<p><strong>NOTE:</strong> Several functions in this module will only work with <a href="https://www.lua.org/pil/11.1.html">arrays</a>,
which are tables with sequentially numbered keys. All table functions will work with arrays as well, but
array functions <strong>will not</strong> work with tables.</p>
<pre><code class="language-lua">local flib_table: = require(&quot;__flib__/table&quot;)
</code></pre>
<h2>array_copy</h2>
<pre><code class="language-lua">function flib_table.array_copy(arr: Array)
  -&gt; Array
</code></pre>
<p>Shallow copy an array's values into a new array.</p>
<p>This function is optimized specifically for arrays, and should be used in place of <code>table.shallow_copy</code> for arrays.</p>
<h2>array_merge</h2>
<pre><code class="language-lua">function flib_table.array_merge(arrays: Array)
  -&gt; Array
</code></pre>
<p>Merge all of the given arrays into a single array.</p>
<p>@<em>param</em> <code>arrays</code> — An array of arrays to merge.</p>
<h2>deep_compare</h2>
<pre><code class="language-lua">function flib_table.deep_compare(tbl1: table, tbl2: table)
  -&gt; boolean
</code></pre>
<p>Recursively compare two tables for inner equality.</p>
<p>Does not compare metatables.</p>
<h2>deep_copy</h2>
<pre><code class="language-lua">function flib_table.deep_copy(tbl: &lt;T&gt;)
  -&gt; &lt;T&gt;
</code></pre>
<p>Recursively copy the contents of a table into a new table.</p>
<p>Does not create new copies of Factorio objects.</p>
<p>@<em>param</em> <code>tbl</code> — The table to make a copy of.</p>
<h2>deep_merge</h2>
<pre><code class="language-lua">function flib_table.deep_merge(tables: Array)
  -&gt; table
</code></pre>
<p>Recursively merge two or more tables.</p>
<p>Values from earlier tables are overwritten by values from later tables, unless both values are tables, in which case
they are recursively merged.</p>
<p>Non-merged tables are deep-copied, so the result is brand-new.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {foo = &quot;bar&quot;}
log(tbl.foo) -- logs &quot;bar&quot;
log (tbl.bar) -- errors (key is nil)
tbl = table.merge{tbl, {foo = &quot;baz&quot;, set = 3}}
log(tbl.foo) -- logs &quot;baz&quot;
log(tbl.set) -- logs &quot;3&quot;
</code></pre>
<p>@<em>param</em> <code>tables</code> — An array of tables to merge.</p>
<h2>filter</h2>
<pre><code class="language-lua">function flib_table.filter(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, filter: fun(value: &lt;V&gt;, key: &lt;K&gt;):boolean, array_insert?: boolean)
  -&gt; table&lt;&lt;K&gt;, &lt;V&gt;&gt;
</code></pre>
<p>Create a filtered version of a table based on the results of a filter function.</p>
<p>Calls <code>filter(value, key)</code> on each element in the table, returning a new table with only pairs for which
<code>filter</code> returned a truthy value.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {1, 2, 3, 4, 5, 6}
local just_evens = table.filter(tbl, function(v) return v % 2 == 0 end) -- {[2] = 2, [4] = 4, [6] = 6}
local just_evens_arr = table.filter(tbl, function(v) return v % 2 == 0 end, true) -- {2, 4, 6}
</code></pre>
<p>@<em>param</em> <code>array_insert</code> — If true, the result will be constructed as an array of values that matched the filter. Key references will be lost.</p>
<h2>find</h2>
<pre><code class="language-lua">function flib_table.find(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, value: &lt;V&gt;)
  -&gt; key: &lt;K&gt;?
</code></pre>
<p>Find and return the first key containing the given value.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {&quot;foo&quot;, &quot;bar&quot;}
local key_of_foo = table.find(tbl, &quot;foo&quot;) -- 1
local key_of_baz = table.find(tbl, &quot;baz&quot;) -- nil
</code></pre>
<p>@<em>param</em> <code>tbl</code> — The table to search.</p>
<p>@<em>param</em> <code>value</code> — The value to match. Must have an <code>eq</code> metamethod set, otherwise will error.</p>
<p>@<em>return</em> <code>key</code> — The first key corresponding to <code>value</code>, if any.</p>
<h2>for_each</h2>
<pre><code class="language-lua">function flib_table.for_each(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, callback: fun(value: &lt;V&gt;, key: &lt;K&gt;):boolean)
  -&gt; Whether: boolean
</code></pre>
<p>Call the given function for each item in the table, and abort if the function returns truthy.</p>
<p>Calls <code>callback(value, key)</code> for each item in the table, and immediately ceases iteration if the callback returns truthy.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {1, 2, 3, 4, 5}
-- Run a function for each item (identical to a standard FOR loop)
table.for_each(tbl, function(v) game.print(v) end)
-- Determine if any value in the table passes the test
local value_is_even = table.for_each(tbl, function(v) return v % 2 == 0 end)
-- Determine if ALL values in the table pass the test (invert the test result and function return)
local all_values_less_than_six = not table.for_each(tbl, function(v) return not (v &lt; 6) end)
</code></pre>
<p>@<em>param</em> <code>callback</code> — Receives <code>value</code> and <code>key</code> as parameters.</p>
<p>@<em>return</em> <code>Whether</code> — the callback returned truthy for any one item, and thus halted iteration.</p>
<h2>for_n_of</h2>
<pre><code class="language-lua">function flib_table.for_n_of(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, from_k: &lt;K&gt;, n: number, callback: fun(value: &lt;V&gt;, key: &lt;K&gt;):&lt;C&gt;, boolean, boolean, _next?: fun(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, from_k: &lt;K&gt;):&lt;K&gt;, &lt;V&gt;)
  -&gt; next_key: &lt;K&gt;?
  2. results: table&lt;&lt;K&gt;, &lt;C&gt;&gt;
  3. reached_end: boolean
</code></pre>
<p>Call the given function on a set number of items in a table, returning the next starting key.</p>
<p>Calls <code>callback(value, key)</code> over <code>n</code> items from <code>tbl</code>, starting after <code>from_k</code>.</p>
<p>The first return value of each invocation of <code>callback</code> will be collected and returned in a table keyed by the
current item's key.</p>
<p>The second return value of <code>callback</code> is a flag requesting deletion of the current item.</p>
<p>The third return value of <code>callback</code> is a flag requesting that the iteration be immediately aborted. Use this flag to
early return on some condition in <code>callback</code>. When aborted, <code>for_n_of</code> will return the previous key as <code>from_k</code>, so
the next call to <code>for_n_of</code> will restart on the key that was aborted (unless it was also deleted).</p>
<p><strong>DO NOT</strong> delete entires from <code>tbl</code> from within <code>callback</code>, this will break the iteration. Use the deletion flag
instead.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local extremely_large_table = {
  [1000] = 1,
  [999] = 2,
  [998] = 3,
  ...,
  [2] = 999,
  [1] = 1000,
}
event.on_tick(function()
  global.from_k = table.for_n_of(extremely_large_table, global.from_k, 10, function(v) game.print(v) end)
end)
</code></pre>
<p>@<em>param</em> <code>tbl</code> — The table to iterate over.</p>
<p>@<em>param</em> <code>from_k</code> — The key to start iteration at, or <code>nil</code> to start at the beginning of <code>tbl</code>. If the key does not exist in <code>tbl</code>, it will be treated as <code>nil</code>, <em>unless</em> a custom <code>_next</code> function is used.</p>
<p>@<em>param</em> <code>n</code> — The number of items to iterate.</p>
<p>@<em>param</em> <code>callback</code> — Receives <code>value</code> and <code>key</code> as parameters.</p>
<p>@<em>param</em> <code>_next</code> — A custom <code>next()</code> function. If not provided, the default <code>next()</code> will be used.</p>
<p>@<em>return</em> <code>next_key</code> — Where the iteration ended. Can be any valid table key, or <code>nil</code>. Pass this as <code>from_k</code> in the next call to <code>for_n_of</code> for <code>tbl</code>.</p>
<p>@<em>return</em> <code>results</code> — The results compiled from the first return of <code>callback</code>.</p>
<p>@<em>return</em> <code>reached_end</code> — Whether or not the end of the table was reached on this iteration.</p>
<h2>get_or_insert</h2>
<pre><code class="language-lua">function flib_table.get_or_insert(table: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, key: &lt;K&gt;, default_value: &lt;V&gt;)
  -&gt; &lt;V&gt;
</code></pre>
<p>Retrieve the value at the key, or insert the default value.</p>
<h2>invert</h2>
<pre><code class="language-lua">function flib_table.invert(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;)
  -&gt; table&lt;&lt;V&gt;, &lt;K&gt;&gt;
</code></pre>
<p>Invert the given table such that <code>[value] = key</code>, returning a new table.</p>
<p>Non-unique values are overwritten based on the ordering from <code>pairs()</code>.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, set = &quot;baz&quot;}
local inverted = table.invert(tbl) -- {foo = 1, bar = 2, baz = &quot;set&quot;}
</code></pre>
<h2>map</h2>
<pre><code class="language-lua">function flib_table.map(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, mapper: fun(value: &lt;V&gt;, key: &lt;V&gt;):&lt;N&gt;?)
  -&gt; table&lt;&lt;K&gt;, &lt;N&gt;&gt;
</code></pre>
<p>Create a transformed table using the output of a mapper function.</p>
<p>Calls <code>mapper(value, key)</code> on each element in the table, using the return as the new value for the key.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {1, 2, 3, 4, 5}
local tbl_times_ten = table.map(tbl, function(v) return v * 10 end) -- {10, 20, 30, 40, 50}
</code></pre>
<h2>partial_sort</h2>
<pre><code class="language-lua">function flib_table.partial_sort(arr: Array&lt;&lt;V&gt;&gt;, from_index?: number, iterations: number, comp: fun(a: &lt;V&gt;, b: &lt;V&gt;))
  -&gt; next_index: number?
</code></pre>
<p>Partially sort an array.</p>
<p>This function utilizes <a href="https://en.wikipedia.org/wiki/Insertion_sort">insertion sort</a>, which is <em>extremely</em> inefficient with large data sets. However, you can spread the sorting over multiple ticks, reducing the performance impact. Only use this function if <code>table.sort</code> is too slow.</p>
<p>@<em>param</em> <code>from_index</code> — The index to start iteration at (inclusive). Pass <code>nil</code> or a number less than <code>2</code> to begin at the start of the array.</p>
<p>@<em>param</em> <code>iterations</code> — The number of iterations to perform. Higher is more performance-heavy. This number should be adjusted based on the performance impact of the custom <code>comp</code> function (if any) and the size of the array.</p>
<p>@<em>param</em> <code>comp</code> — A comparison function for sorting. Must return truthy if <code>a &lt; b</code>.</p>
<p>@<em>return</em> <code>next_index</code> — The index to start the next iteration at, or <code>nil</code> if the end was reached.</p>
<h2>reduce</h2>
<pre><code class="language-lua">function flib_table.reduce(tbl: table&lt;&lt;K&gt;, &lt;V&gt;&gt;, reducer: fun(acc: &lt;R&gt;, value: &lt;V&gt;, key: &lt;K&gt;):&lt;R&gt;, initial_value?: &lt;R&gt;)
  -&gt; &lt;R&gt;
</code></pre>
<p>&quot;Reduce&quot; a table's values into a single output value, using the results of a reducer function.</p>
<p>Calls <code>reducer(accumulator, value, key)</code> on each element in the table, returning a single accumulated output value.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local tbl = {10, 20, 30, 40, 50}
local sum = table.reduce(tbl, function(acc, v) return acc + v end)
local sum_minus_ten = table.reduce(tbl, function(acc, v) return acc + v end, -10)
</code></pre>
<p>@<em>param</em> <code>initial_value</code> — The initial value for the accumulator. If not provided or is falsy, the first value in the table will be used as the initial <code>accumulator</code> value and skipped as <code>key</code>. Calling <code>reduce()</code> on an empty table without an <code>initial_value</code> will cause a crash.</p>
<h2>retrieve</h2>
<pre><code class="language-lua">function
</code></pre>
<h2>shallow_copy</h2>
<pre><code class="language-lua">function flib_table.shallow_copy(tbl: &lt;T&gt;, use_rawset?: boolean)
  -&gt; The: &lt;T&gt;
</code></pre>
<p>Shallowly copy the contents of a table into a new table.</p>
<p>The parent table will have a new table reference, but any subtables within it will still have the same table
reference.</p>
<p>Does not copy metatables.</p>
<p>@<em>param</em> <code>use_rawset</code> — Use rawset to set the values (ignores metamethods).</p>
<p>@<em>return</em> <code>The</code> — copied table.</p>
<h2>shallow_merge</h2>
<pre><code class="language-lua">function flib_table.shallow_merge(tables: table[])
  -&gt; table
</code></pre>
<p>Shallowly merge two or more tables.
Unlike <code>table.deep_merge</code>, this will only combine the top level of the tables.</p>
<h2>size</h2>
<pre><code class="language-lua">function
</code></pre>
<p>Retrieve the size of a table.</p>
<p>Uses Factorio's built-in <code>table_size</code> function.</p>
<h2>slice</h2>
<pre><code class="language-lua">function flib_table.slice(arr: Array&lt;&lt;V&gt;&gt;, start?: number, stop?: number)
  -&gt; A: Array&lt;&lt;V&gt;&gt;
</code></pre>
<p>Retrieve a shallow copy of a portion of an array, selected from <code>start</code> to <code>end</code> inclusive.</p>
<p>The original array <strong>will not</strong> be modified.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local arr = {10, 20, 30, 40, 50, 60, 70, 80, 90}
local sliced = table.slice(arr, 3, 7) -- {30, 40, 50, 60, 70}
log(serpent.line(arr)) -- {10, 20, 30, 40, 50, 60, 70, 80, 90} (unchanged)
</code></pre>
<p>@<em>param</em> <code>start</code> — default: <code>1</code></p>
<p>@<em>param</em> <code>stop</code> — Stop at this index. If zero or negative, will stop <code>n</code> items from the end of the array (default: <code>#arr</code>).</p>
<p>@<em>return</em> <code>A</code> — new array with the copied values.</p>
<h2>splice</h2>
<pre><code class="language-lua">function flib_table.splice(arr: Array&lt;&lt;V&gt;&gt;, start: number, stop?: number)
  -&gt; A: Array&lt;&lt;V&gt;&gt;
</code></pre>
<p>Extract a portion of an array, selected from <code>start</code> to <code>end</code> inclusive.</p>
<p>The original array <strong>will</strong> be modified.</p>
<h3>Examples</h3>
<pre><code class="language-lua">local arr = {10, 20, 30, 40, 50, 60, 70, 80, 90}
local spliced = table.splice(arr, 3, 7) -- {30, 40, 50, 60, 70}
log(serpent.line(arr)) -- {10, 20, 80, 90} (values were removed)
</code></pre>
<p>@<em>param</em> <code>start</code> — default: <code>1</code></p>
<p>@<em>param</em> <code>stop</code> — Stop at this index. If zero or negative, will stop <code>n</code> items from the end of the array (default: <code>#arr</code>).</p>
<p>@<em>return</em> <code>A</code> — new array with the extracted values.</p>
<hr />
<h1>flib_train</h1>
<p>Functions for working with trains.</p>
<pre><code class="language-lua">local flib_train = require(&quot;__flib__/train&quot;)
</code></pre>
<h2>get_backer_name</h2>
<pre><code class="language-lua">function flib_train.get_backer_name(train: LuaTrain)
  -&gt; backer_name: string?
</code></pre>
<p>Get the backer_name of the main locomotive in a given train.</p>
<p>@<em>return</em> <code>backer_name</code> — The backer_name of the primary locomotive or <code>nil</code> when no locomotive was found</p>
<h2>get_composition_string</h2>
<pre><code class="language-lua">function flib_train.get_composition_string(train: LuaTrain)
  -&gt; composition: string?
  2. TrainCompositionCounts?
</code></pre>
<p>Create a string representing train composition, and return a count of locomotives and wagons in the train.</p>
<ul>
<li><code>&lt;L&lt;</code>, <code>&gt;L&gt;</code>: Locomotives</li>
<li><code>C</code>: Cargo wagon</li>
<li><code>F</code>: Fluid wagon</li>
<li><code>A</code>: Artillery wagon</li>
</ul>
<p>@<em>return</em> <code>composition</code> — The composition string, or <code>nil</code> if the train was invalid.</p>
<p>@<em>return</em></p>
<h2>get_main_locomotive</h2>
<pre><code class="language-lua">function flib_train.get_main_locomotive(train: LuaTrain)
  -&gt; locomotive: LuaEntity?
</code></pre>
<p>Get the main locomotive in a given train.</p>
<p>@<em>return</em> <code>locomotive</code> — The primary locomotive entity or <code>nil</code> when no locomotive was found</p>
<h2>open_gui</h2>
<pre><code class="language-lua">function flib_train.open_gui(player_index: number, train: LuaTrain)
  -&gt; boolean
</code></pre>
<p>Open train GUI for one player.</p>
<p>@<em>return</em> — <code>true</code> if the GUI was opened.</p>
<h2>rotate_carriage</h2>
<pre><code class="language-lua">function flib_train.rotate_carriage(entity: LuaEntity)
  -&gt; rotated: boolean
</code></pre>
<p>Rotate a single carriage of a train.</p>
<p>@<em>return</em> <code>rotated</code> — <code>true</code> when rotation was successful.</p>
    </body>
</html>
